// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// import 'ds-auth/auth.sol';
pragma solidity ^0.4.23;

contract DSAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) public view returns (bool);
}

contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}

contract DSAuth is DSAuthEvents {
    DSAuthority  public  authority;
    address      public  owner;

    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }

    function setAuthority(DSAuthority authority_)
        public
        auth
    {
        authority = authority_;
        emit LogSetAuthority(authority);
    }

    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}

/// math.sol -- mixin for inline numerical wizardry

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

pragma solidity ^0.4.13;

contract DSMath {
    function add(uint x, uint y) internal pure returns (uint z) {
        require((z = x + y) >= x);
    }
    function sub(uint x, uint y) internal pure returns (uint z) {
        require((z = x - y) <= x);
    }
    function mul(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function min(uint x, uint y) internal pure returns (uint z) {
        return x <= y ? x : y;
    }
    function max(uint x, uint y) internal pure returns (uint z) {
        return x >= y ? x : y;
    }
    function imin(int x, int y) internal pure returns (int z) {
        return x <= y ? x : y;
    }
    function imax(int x, int y) internal pure returns (int z) {
        return x >= y ? x : y;
    }

    uint constant WAD = 10 ** 18;
    uint constant RAY = 10 ** 27;

    function wmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), WAD / 2) / WAD;
    }
    function rmul(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, y), RAY / 2) / RAY;
    }
    function wdiv(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, WAD), y / 2) / y;
    }
    function rdiv(uint x, uint y) internal pure returns (uint z) {
        z = add(mul(x, RAY), y / 2) / y;
    }

    // This famous algorithm is called "exponentiation by squaring"
    // and calculates x^n with x as fixed-point and n as regular unsigned.
    //
    // It's O(log n), instead of O(n) for naive repeated multiplication.
    //
    // These facts are why it works:
    //
    //  If n is even, then x^n = (x^2)^(n/2).
    //  If n is odd,  then x^n = x * x^(n-1),
    //   and applying the equation for even x gives
    //    x^n = x * (x^2)^((n-1) / 2).
    //
    //  Also, EVM division is flooring and
    //    floor[(n-1) / 2] = floor[n / 2].
    //
    function rpow(uint x, uint n) internal pure returns (uint z) {
        z = n % 2 != 0 ? x : RAY;

        for (n /= 2; n != 0; n /= 2) {
            x = rmul(x, x);

            if (n % 2 != 0) {
                z = rmul(z, x);
            }
        }
    }
}


// import './IkuraStorage.sol';

/**
 *
 * ????????????????????????????
 *
 */
contract IkuraStorage is DSMath, DSAuth {
  // ???????????????
  address[] ownerAddresses;

  // ??????dJPY?????
  mapping(address => uint) coinBalances;

  // ??????SHINJI token?????
  mapping(address => uint) tokenBalances;

  // ???????????????????????????
  mapping(address => mapping (address => uint)) coinAllowances;

  // dJPY????
  uint _totalSupply = 0;

  // ????
  // 0.01pips = 1
  // ?). ???? 0.05% ?????? 500
  uint _transferFeeRate = 500;

  // ??????
  // 1 = 1dJPY
  // amount * ?????????????????????????????????????????????
  uint8 _transferMinimumFee = 5;

  address tokenAddress;
  address multiSigAddress;
  address authorityAddress;

  // @NOTE ??????contract?deploy -> watch contract -> setOwner????
  //??????????????controller??????????????????????
  // ???????????????????????????
  constructor() public DSAuth() {
    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;
    owner = controllerAddress;
    LogSetOwner(controllerAddress);*/
  }

  function changeToken(address tokenAddress_) public auth {
    tokenAddress = tokenAddress_;
  }

  function changeAssociation(address multiSigAddress_) public auth {
    multiSigAddress = multiSigAddress_;
  }

  function changeAuthority(address authorityAddress_) public auth {
    authorityAddress = authorityAddress_;
  }

  // --------------------------------------------------
  // functions for _totalSupply
  // --------------------------------------------------

  /**
   * ???????
   *
   * @return ????
   */
  function totalSupply() public view auth returns (uint) {
    return _totalSupply;
  }

  /**
   * ?????????mint???????????????
   *
   * @param amount ???
   */
  function addTotalSupply(uint amount) public auth {
    _totalSupply = add(_totalSupply, amount);
  }

  /**
   * ?????????burn???????????????
   *
   * @param amount ???
   */
  function subTotalSupply(uint amount) public auth {
    _totalSupply = sub(_totalSupply, amount);
  }

  // --------------------------------------------------
  // functions for _transferFeeRate
  // --------------------------------------------------

  /**
   * ???????
   *
   * @return ???????
   */
  function transferFeeRate() public view auth returns (uint) {
    return _transferFeeRate;
  }

  /**
   * ?????????
   *
   * @param newTransferFeeRate ???????
   *
   * @return ????????true??????false?????????????????
   */
  function setTransferFeeRate(uint newTransferFeeRate) public auth returns (bool) {
    _transferFeeRate = newTransferFeeRate;

    return true;
  }

  // --------------------------------------------------
  // functions for _transferMinimumFee
  // --------------------------------------------------

  /**
   * ???????
   *
   * @return ????????
   */
  function transferMinimumFee() public view auth returns (uint8) {
    return _transferMinimumFee;
  }

  /**
   * ??????????
   *
   * @param newTransferMinimumFee ????????
   *
   * @return ????????true??????false?????????????????
   */
  function setTransferMinimumFee(uint8 newTransferMinimumFee) public auth {
    _transferMinimumFee = newTransferMinimumFee;
  }

  // --------------------------------------------------
  // functions for ownerAddresses
  // --------------------------------------------------

  /**
   * ?????????????????????????
   *
   * ?????????????????????????????????
   * ???????? = ?????????????????????????????????
   * ??????????????????????????????????????????
   *
   * @param addr ?????????
   *
   * @return ????????true??????false
   */
  function addOwnerAddress(address addr) internal returns (bool) {
    ownerAddresses.push(addr);

    return true;
  }

  /**
   * ??????????????????????????
   *
   * ?????????????????????????????????
   *
   * @param addr ?????????????????
   *
   * @return ????????true??????false
   */
  function removeOwnerAddress(address addr) internal returns (bool) {
    uint i = 0;

    while (ownerAddresses[i] != addr) { i++; }

    while (i < ownerAddresses.length - 1) {
      ownerAddresses[i] = ownerAddresses[i + 1];
      i++;
    }

    ownerAddresses.length--;

    return true;
  }

  /**
   * ????????contract?deploy???????????????
   *
   * @return ????????????
   */
  function primaryOwner() public view auth returns (address) {
    return ownerAddresses[0];
  }

  /**
   * ????????????????????????????
   *
   * @param addr ?????????
   *
   * @return ??????????????true???????????false
   */
  function isOwnerAddress(address addr) public view auth returns (bool) {
    for (uint i = 0; i < ownerAddresses.length; i++) {
      if (ownerAddresses[i] == addr) return true;
    }

    return false;
  }

  /**
   * ????????
   *
   * @return ?????
   */
  function numOwnerAddress() public view auth returns (uint) {
    return ownerAddresses.length;
  }

  // --------------------------------------------------
  // functions for coinBalances
  // --------------------------------------------------

  /**
   * ?????????dJPY?????
   *
   * @param addr ?????????
   *
   * @return dJPY??
   */
  function coinBalance(address addr) public view auth returns (uint) {
    return coinBalances[addr];
  }

  /**
   * ?????????dJPY???????
   *
   * @param addr ?????????
   * @param amount ??
   *
   * @return ????????true??????false
   */
  function addCoinBalance(address addr, uint amount) public auth returns (bool) {
    coinBalances[addr] = add(coinBalances[addr], amount);

    return true;
  }

  /**
   * ?????????dJPY???????
   *
   * @param addr ?????????
   * @param amount ??
   *
   * @return ????????true??????false
   */
  function subCoinBalance(address addr, uint amount) public auth returns (bool) {
    coinBalances[addr] = sub(coinBalances[addr], amount);

    return true;
  }

  // --------------------------------------------------
  // functions for tokenBalances
  // --------------------------------------------------

  /**
   * ?????????SHINJI??????????
   *
   * @param addr ?????????
   *
   * @return SHINJI??????
   */
  function tokenBalance(address addr) public view auth returns (uint) {
    return tokenBalances[addr];
  }

  /**
   * ?????????SHINJI???????????
   *
   * @param addr ?????????
   * @param amount ??
   *
   * @return ????????true??????false
   */
  function addTokenBalance(address addr, uint amount) public auth returns (bool) {
    tokenBalances[addr] = add(tokenBalances[addr], amount);

    if (tokenBalances[addr] > 0 && !isOwnerAddress(addr)) {
      addOwnerAddress(addr);
    }

    return true;
  }

  /**
   * ?????????SHINJI???????????
   *
   * @param addr ?????????
   * @param amount ??
   *
   * @return ????????true??????false
   */
  function subTokenBalance(address addr, uint amount) public auth returns (bool) {
    tokenBalances[addr] = sub(tokenBalances[addr], amount);

    if (tokenBalances[addr] <= 0) {
      removeOwnerAddress(addr);
    }

    return true;
  }

  // --------------------------------------------------
  // functions for coinAllowances
  // --------------------------------------------------

  /**
   * ?????????
   *
   * @param owner_ ???
   * @param spender ?????
   *
   * @return ??????
   */
  function coinAllowance(address owner_, address spender) public view auth returns (uint) {
    return coinAllowances[owner_][spender];
  }

  /**
   * ??????????????????
   *
   * @param owner_ ???
   * @param spender ?????
   * @param amount ??
   *
   * @return ????????true??????false
   */
  function addCoinAllowance(address owner_, address spender, uint amount) public auth returns (bool) {
    coinAllowances[owner_][spender] = add(coinAllowances[owner_][spender], amount);

    return true;
  }

  /**
   * ??????????????????
   *
   * @param owner_ ???
   * @param spender ?????
   * @param amount ??
   *
   * @return ????????true??????false
   */
  function subCoinAllowance(address owner_, address spender, uint amount) public auth returns (bool) {
    coinAllowances[owner_][spender] = sub(coinAllowances[owner_][spender], amount);

    return true;
  }

  /**
   * ?????????????????
   *
   * @param owner_ ???
   * @param spender ?????
   * @param amount ??????
   *
   * @return ????????true??????false
   */
  function setCoinAllowance(address owner_, address spender, uint amount) public auth returns (bool) {
    coinAllowances[owner_][spender] = amount;

    return true;
  }

  /**
   * ??????????override
   *
   * @param src ???????
   * @param sig ????????
   *
   * @return ???????????true????????false
   */
  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
    sig; // #HACK

    return  src == address(this) ||
            src == owner ||
            src == tokenAddress ||
            src == authorityAddress ||
            src == multiSigAddress;
  }
}

/**
 *
 * ??????????????
 *
 */
contract IkuraAuthority is DSAuthority, DSAuth {
  // ????????????
  IkuraStorage tokenStorage;

  // ?????????????????????????????
  // #TODO ??????????????????????????storage????????????????
  mapping(bytes4 => bool) actionsWithToken;

  // ????????????????????
  mapping(bytes4 => bool) actionsForbidden;

  // @NOTE ??????contract?deploy -> watch contract -> setOwner????
  //??????????????controller??????????????????????
  // ???????????????????????????
  constructor() public DSAuth() {
    /*address controllerAddress = 0x34c5605A4Ef1C98575DB6542179E55eE1f77A188;
    owner = controllerAddress;
    LogSetOwner(controllerAddress);*/
  }

  /**
   * ??????????
   *
   * @param storage_ ?????????????
   */
  function changeStorage(address storage_) public auth {
    tokenStorage = IkuraStorage(storage_);

    // ?????????????????????????????
    actionsWithToken[stringToSig('mint(uint256)')] = true;
    actionsWithToken[stringToSig('burn(uint256)')] = true;
    actionsWithToken[stringToSig('confirmProposal(string, uint256)')] = true;
    actionsWithToken[stringToSig('numberOfProposals(string)')] = true;

    // ???????????????????????
    actionsForbidden[stringToSig('forbiddenAction()')] = true;
  }

  /**
   * ???????override
   * ??????????
   *
   * @param src ???????
   * @param dst ??contract
   * @param sig ????????
   *
   * @return ????????????true?????????false
   */
  function canCall(address src, address dst, bytes4 sig) public constant returns (bool) {
    // ?????????????????????????????
    if (actionsWithToken[sig]) return canCallWithAssociation(src, dst);

    // ??????????????????
    if (actionsForbidden[sig]) return canCallWithNoOne();

    // ????????????
    return canCallDefault(src);
  }

  /**
   * ???????????????????????????
   *
   * @return ??????????????true?????????false
   */
  function canCallDefault(address src) internal view returns (bool) {
    return tokenStorage.isOwnerAddress(src);
  }

  /**
   * ?????????????????????
   *
   * @param src ???????
   * @param dst ??contract
   *
   * @return ?????????????true?????????false
   */
  function canCallWithAssociation(address src, address dst) internal view returns (bool) {
    // warning??
    dst;

    return tokenStorage.isOwnerAddress(src) &&
           (tokenStorage.numOwnerAddress() == 1 || tokenStorage.tokenBalance(src) > 0);
  }

  /**
   * ??????????????????
   * ?????????
   *
   * @return ??false???
   */
  function canCallWithNoOne() internal pure returns (bool) {
    return false;
  }

  /**
   * ??????function identifier?????
   *
   * #see http://solidity.readthedocs.io/en/develop/units-and-global-variables.html#block-and-transaction-properties
   *
   * @param str ????
   *
   * @return ???????????4???
   */
  function stringToSig(string str) internal pure returns (bytes4) {
    return bytes4(keccak256(str));
  }
}